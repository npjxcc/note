<!--
 * @FilePath: C++.md
 * @Author: 能跑就行 485553522@qq.com
 * @Date: 2023-11-26
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2023-11-26
-->
<https://zhuanlan.zhihu.com/p/491657266>

/
多看看下面这个链接的内容
<https://www.zhihu.com/question/317298419/answer/2153471449>

# 目录

[TOC]

## C++基础

### C++变量作用域

有三个地方定义变量

*   局部变量
*   形式参数
*   全局变量
*

其中作用域又包括

*   局部作用域：局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
*   全局作用域：全局变量在程序开始时被创建，在程序结束时被销毁。
*   块作用域：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。`{  }之内的，就算是代码块`
*   类作用域：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。
*

### C++ inline内联函数详解

内联函数差不多等同于C语言的宏展开

```C++
    #include <iostream>
    using namespace std;
    
    //内联函数，交换两个数的值
    inline void swap(int *a, int *b){
        int temp;
        temp = *a;
        *a = *b;
        *b = temp;
    }
    
    int main(){
        int m, n;
        cin>>m>>n;
        cout<<m<<", "<<n<<endl;
        swap(&m, &n);
        cout<<m<<", "<<n<<endl;
    
        return 0;
    }
```

当编译器遇到函数调用swap(\&m, \&n)时，会用 swap() 函数的代码替换swap(\&m, \&n)，同时用实参代替形参。这样，程序第 36 行就被置换成：

```C++
    int temp;
    temp = *(&m);
    *(&m) = *(&n);
    *(&n) = temp;
```

==函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。==
`使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。`

### C++函数的默认参数详解

```C++
    float d = 10.8;
    void func(int n, float b=d+2.9, char c='@'){
        cout<<n<<", "<<b<<", "<<c<<endl;
    }
```

C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。

### C++函数重载详解

C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading）
==参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。==

```C++
#include <iostream>
using namespace std;

//交换 int 变量的值
void Swap(int *a, int *b){
    int temp = *a;
    *a = *b;
    *b = temp;
}

//交换 float 变量的值
void Swap(float *a, float *b){
    float temp = *a;
    *a = *b;
    *b = temp;
}

//交换 char 变量的值
void Swap(char *a, char *b){
    char temp = *a;
    *a = *b;
    *b = temp;
}

//交换 bool 变量的值
void Swap(bool *a, bool *b){
    char temp = *a;
    *a = *b;
    *b = temp;
}

int main(){
    //交换 int 变量的值
    int n1 = 100, n2 = 200;
    Swap(&n1, &n2);
    cout<<n1<<", "<<n2<<endl;
   
    //交换 float 变量的值
    float f1 = 12.5, f2 = 56.93;
    Swap(&f1, &f2);
    cout<<f1<<", "<<f2<<endl;
   
    //交换 char 变量的值
    char c1 = 'A', c2 = 'B';
    Swap(&c1, &c2);
    cout<<c1<<", "<<c2<<endl;
   
    //交换 bool 变量的值
    bool b1 = false, b2 = true;
    Swap(&b1, &b2);
    cout<<b1<<", "<<b2<<endl;

    return 0;
}
```

重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。重载的结果是让一个函数名拥有了多种用途，使得命名更加方便（在中大型项目中，给变量、函数、类起名字是一件让人苦恼的问题），调用更加灵活。

注意，参数列表不同包括参数的个数不同、类型不同或顺序不同，仅仅参数名称不同是不可以的。函数返回值也不能作为重载的依据。

函数的重载的规则：
函数名称必须相同。
参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。
函数的返回类型可以相同也可以不相同。
仅仅返回类型不同不足以成为函数的重载。

##### C++ 是如何做到函数重载的

`同一函数定义几个版本，从而使一个函数名具有多种功能。`
C++代码在编译时会根据参数列表对函数进行重命名，发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）
从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

### C++类的定义和对象的创建详解

C++的类，相当于C语言结构体的升级版
C语言中的 struct 只能包含变量，而C++中的 class 除了可以包含变量，还可以包含函数。

结构体和类都可以看做一种由用户自己定义的复杂数据类型，在C语言中可以通过结构体名来定义变量，在 C++ 中可以通过类名来定义变量。不同的是，通过结构体定义出来的变量还是叫变量，而通过类定义出来的变量有了新的名称，叫做对象（Object）。

#### 类及其实例化

对象就是一类物体的实例，将一组对象的共同特征抽象出来，从而形成“类”的概念。

*   类中声明的任何成员不能使用extern、auto和register关键字进行修饰，类中有数据成员和函数成员，而且不能在类声明中对数据成员使用表达式进行初始化。

```C++
class 类名
{
    //私有数据和函数
    private:
    //公有数据和函数
    public:
    //保护数据和函数
    protected:
};
```

**1. 类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了**

也可以像使用C指针一样去操作它

```C++
//第一种
Student stu;
Student *pStu = &stu;

//第二种
Student *pStu = new Student;
```

其次，不能在类体内给数据成员赋值。数据成员的具体值是用来描述对象的属性的。只有产生了一个具体的对象，这些值才有意义。如果在产生对象时就使对象的数据成员具有指定值，则称为对象的初始化。

**2. 对象和引用都使用运算符“.”访问对象的成员，指针则使用“- >”运算符。**
成员使用规律:

*   类的成员函数可以直接使用自己类的私有、保护和公有成员（数据成员和成员函数）。
*   在类外不能直接使用私有、保护成员，但可以使用公有成员来间接访问私有、保护成员。
*   可以定义类的多个对象，不同的对象可以有不同的属性值。

1.  数据封装
    C++对其对象的数据成员和成员函数的访问是通过访问控制权限来限制的。C++通过**类实现**数据封装，即**指定类成员的访问权限来实现**。

2.  this指针

*   this指针隐含于**每一个类的成员函数**中,每一个类的成员函数都有一个this指针变量，当某个对象调用成员函数时，this指针指向这个对象。
*   this指针由编译器自动产生、调用。通过this指针可以引用到对象的任何成员（静态成员没有this指针）。成员函数也可以显式使用this指针。经常省略“- >”。
    具体实例如下

```C++
```

1.  一个类的对象作为另一个类的成员
    类的数据成员，可以是普通的数据类型，也可以是类对象类型。执行构造函数时，先执行成员对象的构造函数，再执行本身类的构造函数。

```C++
#include <iostream>

class A {
    public : A( ){ std::cout << "A" ;} 
};

class B {
    A  a;
    public : B( ){ std::cout << "B" ;} 
};

int main(void) 
{
    B b;
    return 1;
}
```

结果是 `AB`

1.  类和对象的性质
    1.  对象的性质
        （1）同类对象之间可以相互赋值。
        （2）可使用对象数组。
        （3）可使用指向对象的指针。
        （4）对象可以用作函数参数。
        （5）对象作为函数参数时，可使用对象、对象引用和对象指针。
        （6）一个对象可以作为另一个类的成员。
    2.  类的性质
        （1）使用类权限，类本身成员可以使用类的所有成员；类对象只能访问公有成员；其他函数不能使用类的私有成员，也不能使用公有成员函数。
        （2）不完全的类声明，用于在类没有定义之前就引用该类的情况。不完全声明的类不能实例化。
        如
        （3）空类不包括任何声明，如class A{};
        （4）类作用域：声明类时使用的一对花括号形成类作用域。
        使用struct、class都可以设计类，但struct默认权限是public类型，而class默认为private类型。

### C++ 构造函数和析构函数详解

*   构造函数：主要作用于创建函数时对对象成员的属性赋值
    *   **构造函数语法**：类名( ){ }
        *   构造函数，没有返回值也不写void
        *   函数名称与类名相同
        *   构造函数可以有参数，因此可以发生重载
        *   程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次
*   析构函数：主要作用于在对象销毁前，执行一些清理工作(如释放new开辟在堆区的空间)
    *   **析构函数语法**： \~类名( ){ }
        *   析构函数，没有返回值也不写void
        *   函数名称与类名相同,在名称前加上符号 \~
        *   析构函数不可以有参数，因此不可以发生重载
        *   程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次
*   其余注意
    *   构造函数和析构函数是一种特殊的公有成员函数，每一个类都有一个默认的构造函数和析构函数；
    *   构造函数在类定义时由系统自动调用，析构函数在类被销毁时由系统自动调用；
    *   构造函数的名称和类名相同，**一个类可以有多个构造函数，只能有一个析构函数**。**不同的构造函数之间通过参数个数和参数类型来区分**
    *   我们可以在构造函数中给类分配资源，在类的析构函数中释放对应的资源。
    *   如果程序员没有提供构造和析构，系统会**默认提供，空实现**
    *   构造函数 和 析构函数，必须定义在**public**里面，才可以调用

### C++中的::

一、作用域符号：
作用域符号”::“的前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分。

例如：A,B表示两个类，在A,B中都有成员member。
那么：
1、A::member就表示类A中的成员member。
2、B::member就表示类B中的成员member。

二、全局作用域符号：
全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分，例如：

```C++
char num;

void test()
{
    char num;
    char(局部) = char(局部) * char(局部);
    ::char(全局) = ::char(全局) * char(局部)；
}
```

三、作用域分解运算符：
\::是C++里的作用域分解运算符，“比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。例如：

```C++
class TEST{
    public:
    int a;
    int add(int a, int b);
    int add(int a);
};
//可以在外部去实现函数定义
int TEST::add(int a, int b)
{
    rerutn a + b;
}
//也可以类变量内部作为当前类实例元素进行表示
int TEST::add(int a)
{
    return a + ::a;
}
```

5.对象的定义和初始化
Int z(0); 等价于int z=0;

3.动态分配内存
new 类型名\[size]
指针名 = new 结构名；//分配
delete 指针名； //释放
